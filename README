
Multi-agent Epistemic Cooperation-Agnostic (MECA) Planner
david.buckingham@tufts.edu

 
+---------------------------------------+
|                BUILD                  |
+---------------------------------------+

Build the planer:

$ make

Among other things, this generates "meca" and "mecad", the difference is that
mecad turns on java asserts: most of the planner's run-time error checking uses
asserts instead of exceptions. I try to use exceptions when checking user input
such as problem files, configuration files, and model files.


Build the simulator:

$ make simulator

This generates "sim". This is a small tool to execute a plan that has been
generated by the planner. It queries the user to determine the actions of
e-agents.


If things get weird:

$ make clean

Building java projects with Make can be tricky (See the O'Reilly book "Managing
Projects with GNU Make"), and I'm not that good at Make anyway: this build
system is prone to breaking.


+---------------------------------------+
|                 EXAMPLE               |
+---------------------------------------+

$ ./mecad problems/pizza.depl configs/example.conf

The planner takes one required argument and one optional argument.
The required argument is a .depl file describing a planning problem.
The optional argument is a .conf configuration file.
The order doesn't matter, the filename extensions do.

+---------------------------------------+
|         CONFIGURATION FILES           |
+---------------------------------------+


DEPL:
= language to define planning problems.
The grammar is defined in "src/deplParser/Depl.g4",
which is written in the ANTLR meta-language, which is simmilar to a BNF.



TOUR:
Some of the main directories and files to look at.

src/simulator/Simulator.java
This simulator reads a serialized plan and a domain. It transitions states by
applying actions from the planner and queries the user to select e-agent actions
from among the actions predicted by the e-agent's model.

src/mecaPlanner/Planner.java
The main class for running the planner. Reads options, and planner input, runs
search, prints/saves solution.

src/mecaPlanner/Search.java
This is the actually planner search. We can probably call this directly from the
simulation and not use Planner.java

src/mecaPlanner/Domain.java
A static class (for now). The domain file fills this out, and its read by
several classes at different times during planning.



OUTPUT:
The output is a "Solution" object ("src/maePlanner/Solution.java"). If the
planner failed, the "failed()" method will return "true". Otherwise, the
"getPolicy()" method will return a map from epistemic states
("src/maePlanner/EpistemicState.java") to actions ("src/maePlanner/Action.java"
and its various subclasses) that is a safe, non-syclic solution to the
problem. "getDepth()" gives the (worst case) number of actions needed to reach
a goals state, and "getCost()" gives the sum of the costs of those actions.


----- SIMULATOR -----

gg
