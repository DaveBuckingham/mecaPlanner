types{
    location-object,
    locatable-object,
    actor-locatable,
}

objects{
    robot-actor,
    sheep-actor,
    knight-actor,
    dragon-actor,
    field-location,
    forest-location,
    castle-location,
    lair-location,
}

agents{
    robot,
    sheep{sheep.SheepModel},
    knight{sheep.KnightModel},
    dragon{sheep.DragonModel},
}

passive{}

fluents{
    at[?a-locatable,?b-location](?a,?b),
    jousting(),
    robot_has_turnip(),
    knight_has_treasure(),
    sheep_alive(),
}

constants{
    sameLocation[?a-location,?b-location](?a,?b);
}

constraints{
    sameLocation(field,field),
    sameLocation(forest,forest),
    sameLocation(castle,castle),
    sameLocation(lair,lair),
}

initially{
    sheep_alive(),
    at(sheep,field),
    at(robot,castle),
    at(knight,castle),
    at(dragon,lair),
    C(~B_knight(at(dragon,lair)) & ~B_knight(~at(dragon,lair)))
}

goals{
    t>=5 & sheep_alive()
}

actions{

    announce_dragon[](){
        owner{robot},
        observes[?o - actor]{?o},
        announces[]{at(dragon,lair)},
    }

    announce_treasure[](){
        owner{robot},
        observes[?o - actor]{?o},
        announces[]{knight_has_treasure()},
    }

    take_turnip[](){
        owner{robot},
        precondition{at(robot,field) & ~robot_has_turnip()},
        observes{robot},
        observes{sheep},
        observes{knight},
        observesif{dragon, ~jousting()},
        causes{robot_has_turnip}
    }

    joust[?l-location](?l){
        owner{dragon},
        precondition{~jousting & at(dragon,?l) & at(knight,?l)},
        observes[?o-actor]{?o},
        causes{jousting}
    }

    eat_sheep[?l-location](?l) {
        owner{dragon},
        precondition{at(dragon,?l) & at(sheep,?l)},
        observes[?o-actor]{?o},
        causes{~sheep_alive}
        causes{~at(sheep,?l)}
    }

    move[?a-actor, ?f-location,?t-location](?f,?t){
        owner{?a},
        precondition{at(?a, ?f)},
        precondition{~sameLocation(?f,?t)},
        observes{?a},
        observes{robot},
        observes{sheep},
        observes{knight},
        observesif{dragon, ~jousting()}
        causes{~(at(?a, ?f))},
        causes{at(?a, ?t)},
    }

    wait[?a-actor]() {
        owner{?a},
        observes[?o-actor]{?o},
    }


}
