types{
    location-object,
    locatable-object,
    actor-locatable,
}

objects{
    robot-actor,
    sheep-actor,
    knight-actor,
    dragon-actor,
    field-location,
    forest-location,
    castle-location,
    hill-location,
}

agents{
    robot,
    sheep{sheep.SheepModel},
    knight{sheep.KnightModel},
    dragon{sheep.DragonModel},
}

passive{}

fluents{
    at[?a-locatable,?b-location](?a,?b),
    dueling(),
    knight_has_treasure(),
    sheep_alive(),
}

constants{
    sameLocation[?a-location,?b-location](?a,?b)
}

constraints{
    sameLocation(field,field),
    sameLocation(forest,forest),
    sameLocation(castle,castle),
    sameLocation(hill,hill),
}

initially{
    sheep_alive(),
    at(sheep,field),
    at(robot,field),
    at(knight,field),
    at(dragon,hill),
    C(~B_knight(at(dragon,hill)) & ~B_knight(~at(dragon,hill)))
}

goals{
    t>=15 & sheep_alive()
}

actions{

//    announce_dragon[?l-location](){
//        owner{robot},
//        observesif[?o - actor]{?o, at(?o,?l)},
//        announces[]{at(dragon,hill)},
//    }

    announce_treasure[?l-location](?l){
        owner{robot},
        precondition{at(robot,?l)},
        observesif[?o - actor]{?o, at(?o,?l)},
        announces[]{knight_has_treasure()},
    }

    duel[?l-location](?l){
        owner{dragon},
        precondition{at(dragon,?l) & at(knight,?l)},
        observes[?o-actor]{?o},
        causes{dueling}
    }

    duel[?l-location](?l){
        owner{knight},
        precondition{~dueling & at(dragon,?l) & at(knight,?l)},
        observes[?o-actor]{?o},
        causes{dueling}
    }

    eat_sheep[?l-location](?l) {
        owner{dragon},
        precondition{at(dragon,?l) & at(sheep,?l)},
        observes[?o-actor]{?o},
        causes{~sheep_alive}
        causes{~at(sheep,?l)}
    }

    move[?a-actor, ?f-location,?t-location](?f,?t){
        owner{?a},
        precondition{at(?a, ?f)},
        precondition{~sameLocation(?f,?t)},
        observes{?a},
        observes{robot},
        observes{sheep},
        observes{knight},
        observes{dragon},
        observesif{dragon, ~dueling()}
        causes{~(at(?a, ?f))},
        causes{at(?a, ?t)},
    }

    wait[?a-actor]() {
        owner{?a},
        observes[?o-actor]{?o},
    }


}
