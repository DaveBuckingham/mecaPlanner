types{
    Robot-Actor,
    Human-Actor,
    Actor-Locatable,
    Food-Locatable,
    Locatable-Object,
    Location-Object
}

objects{
    robot1-Robot,
    human1-Human,
    pizza-Food,
    hotdog-Food,
    room1 - Location,
    room2 - Location,
}

agents{
    robot1,
    human1{PizzaModel},
}


fluents{
    at(Locatable, Locatable) - Boolean,
    human_hungry()- Boolean,
    door_open() - Boolean,
    robot_charged() - Boolean,
}


initially{
    w1 <-
    {
        at(human1, room1) <- true,
        at(robot1, room1) <- true,
        at(pizza,room1) <- true,
        at(hotdog,room2) <- true,
        human_hungry() <- true
    }
    B[human1] <- {(w1,w1)},
    K[human1] <- {(w1,w1)},
    B[robot1] <- {(w1,w1)},
    K[robot1] <- {(w1,w1)},
}

goals{
    robot_charged(),
}

actions{
    move(?a-Actor,?f-Location,?t-Location){
        owner{?a},
        precondition{at(?a, ?f)},
        precondition{door_open()},
        precondition{~same(?f,?t)},
        observes(?o-Actor){?o},
        causes{at(?a, ?t)},
        causes{~(at(?a, ?f))},
    }

    open_door(){
        owner{human1},
        precondition{~door_open()},
        observes(?o-Actor){?o},
        causes{door_open()},
    }

    charge(){
        owner{robot1},
        precondition{at(robot1,room2)},
        observes(?o-Actor){?o},
        causes{robot_charged()},
    }


    eat(?f-Food,?l-Location,?r-Robot){
        owner{?r},
        precondition{at(?r, ?l)},
        precondition{at(?f, ?l)},
        observes(?o-Actor){?o},
        causes{~(at(?f, ?l))},
    }

    eat(?f-Food,?l-Location,?h-Human){
        owner{?h},
        precondition{at(?h, ?l)},
        precondition{at(?f, ?l)},
        observes(?o-Actor){?o},
        causes{~(at(?f, ?l))},
        causes{~(human_hungry())},
    }

    wait(?a - Actor) {
        owner{?a},
        observes(?o-Actor){?o},
    }
}
