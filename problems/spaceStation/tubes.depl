// domain for base case (1H1R, simple environment and actions)

types{
    human-actor,
    robot-actor,
    actor-locatable,  // for use in predicates
    locatable-object,
    location-object,
    tool-object
}

objects{
    alpha-location,
    beta-location,
    gamma-location,
    robot1-robot,
    human1-human,
    microphone-tool,
    welder-tool,
    commander-role,
    scout-role,
    repair-role,
}

// can be used as agents in belief formulae, observe, and can be assigned models
agents{
    robot1,
    human1{HumanModel},
    //human1,
}

predicates{
    damaged(alpha),
    damaged(beta),
    damaged(gamma),
    on(alpha),
    on(beta),
    on(gamma),
    off(alpha),
    off(beta),
    off(gamma),
    inLocation[?a - locatable, ?b - location](?a,?b),
    working[?a- agent, ?t - tool](?a,?t),
    hasRole[?a - agent, ?r - role](?a,?r),
    //moved[?a-agent,?l-location](?l),
    repaired[?l-location](?l),
    // add belief and common knowledge?
}

initially{
    damaged(alpha),
    damaged(beta),
    damaged(gamma),
    on(alpha),
    on(beta),
    on(gamma),
    inLocation(human1, alpha),
    inLocation(robot1, alpha),
    working(robot1, microphone),

    C(B_human1(inLocation(robot1,alpha))),

    C(B_robot1(inLocation(human1,alpha))),

    // human doesn't believe that robot is in the other rooms?
    // above predicates for the robot
    // C(~(B_human1(atTube(robot1,control_room))) & ~(B_human1(~(atTube(robot1,control_room))))), 
}

goals{
//    ~(damaged(alpha)),
//    ~(damaged(beta)),
//    ~(damaged(gamma)),
//    on(alpha),
//    on(beta),
//    on(gamma),
      (~damaged(alpha) & on(alpha)) | (~damaged(beta) & on(beta)) | (~damaged(gamma) & on(gamma))
}

actions{

/*    // e.g., alpha to beta
    move_from_location_to_location[?a-actor,?f-location,?t-location](?f,?t){
        owner{?a},
        cost{2},
        precondition{inLocation(?a,?f)},
        precondition{~inLocation(?a,?t)},
        observes[?o-actor]{?o}, 
	causes{inLocation(?a,?t)},
        causes{~(inLocation(?a,?f))},
    }
*/

    move_from_location_to_location[?a-actor](alpha,beta){
        owner{?a},
        cost{2},
        precondition{inLocation(?a,alpha)},
        precondition{~inLocation(?a,beta)},
        observes[?o-actor]{?o},
	causes{inLocation(?a,beta)},
        causes{~(inLocation(?a,alpha))},
    }

    move_from_location_to_location[?a-actor](beta,alpha){
        owner{?a},
        cost{2},
        precondition{inLocation(?a,beta)},
        precondition{~inLocation(?a,alpha)},
        observes[?o-actor]{?o},
	causes{inLocation(?a,alpha)},
        causes{~(inLocation(?a,beta))},
    }

    move_from_location_to_location[?a-actor](alpha,gamma){
        owner{?a},
        cost{2},
        precondition{inLocation(?a,alpha)},
        precondition{~inLocation(?a,gamma)},
        observes[?o-actor]{?o},
	causes{inLocation(?a,gamma)},
        causes{~(inLocation(?a,alpha))},
    }

    move_from_location_to_location[?a-actor](gamma,alpha){
        owner{?a},
        cost{2},
        precondition{inLocation(?a,alpha)},
        precondition{~inLocation(?a,beta)},
        observes[?o-actor]{?o},
	causes{inLocation(?a,beta)},
        causes{~(inLocation(?a,alpha))},
    }

    move_from_location_to_location[?a-actor](beta,gamma){
        owner{?a},
        cost{2},
        precondition{inLocation(?a,beta)},
        precondition{~inLocation(?a,gamma)},
        observes[?o-actor]{?o},
	causes{inLocation(?a,gamma)},
        causes{~(inLocation(?a,beta))},
    }

    move_from_location_to_location[?a-actor](gamma,beta){
        owner{?a},
        cost{2},
        precondition{inLocation(?a,gamma)},
        precondition{~inLocation(?a,beta)},
        observes[?o-actor]{?o},
	causes{inLocation(?a,beta)},
        causes{~(inLocation(?a,gamma))},
    }
    
    wait[?a-actor]() {
        owner{?a},
	cost{1},
    }

    repair[?r-robot, ?l-location](?l){
        owner{?r},
	cost{2},
        precondition{damaged(?l)},
	precondition{inLocation(?r,?l)},
        precondition{off(?l)},
	observes[?r-robot]{?r},
        observesif[?o - actor]{?o,inLocation(?o,?l)},
        causes{~(damaged(?l))},
	causes{repaired(?l)},
    }

    turn_panel_on[?a-actor,?l-location](?l){
        owner{human1},
        cost{2},
	precondition{repaired(?l)},
        precondition{inLocation(human1,?l)},
        precondition{off(?l)},
        observesif[?o - actor]{?o,inLocation(?o,?l)},
	causes{on(?l)},
    }


    turn_panel_off[?a-actor,?l-location](?l) {
        owner{human1},
        cost{2},
        precondition{inLocation(human1,?l)},
        precondition{on(?l)},
	precondition{damaged(?l)},
        observesif[?o - actor]{?o,inLocation(?o,?l)},
        causes{off(?l)},
    }


//    monitor_wing[?r-robot, ?w-location, ?t-tube](?w,?t) {
//        owner{?r},
//        cost{0},
//        precondition{inLocation(?r,?w)},
//        determines{damaged(?t)},
//    }

    announce_repair[?r-robot,?l-location](?l){
	owner{?r},
    	cost{1},
	precondition{inLocation(?r,?l)},
    	precondition{repaired(?l)},
	precondition{(~B_human1(damaged(?l)) | B_human1(~damaged(?l)))},
    	observes[?o-actor]{?o},   
    	announces{repaired(?l)},
    }

//    announce_move[?a-actor,?l-location](?t){
//	owner{robot1},
//	cost{0},
//      precondition{moved(robot1,?l)},
//	precondition{announces(at(robot1,?l))},
//	observes[?o-actor]{?o},   
//	announces{moved(robot1,?l)},
//    }

    announce_damaged[?r-robot,?l-location](?l){
	owner{?r},
	cost{1},
	precondition{inLocation(?r,?l)},
	precondition{damaged(?l)},
        precondition{(~B_human1(damaged(?l))},
	observes[?o-actor]{?o},   
	announces{damaged(?l)},
    }

    announce_on[?r-robot,?l-location](?l){
	owner{?r},
	cost{1},
	precondition{on(?l)},
	precondition{inLocation(?r,?l)},
	observes[?o-actor]{?o},   
	announces{on(?l)},
    }

    announce_off[?r-robot,?l-location](?l){
	owner{?r},
	cost{1},
	precondition{off(?l)},
	precondition{inLocation(?r,?l)},
	observes[?o-actor]{?o},   
	announces{off(?l)},
    }

    switch_role_scout[?r-robot](){
        owner{?r},
	cost{1},
        precondition{~working(?r,welder)},
        observes[?r-robot]{?r},
        causes{hasRole(?r,scout)},
	causes{~hasRole(?r,repair)},
    }

    switch_role_repair[?r-robot](){
        owner{?r},
	cost{1},
        precondition{~working(?r,microphone)},
        observes[?r-robot]{?r},
        causes{hasRole(?r,repair)},
	causes{~hasRole(?r,repair)},
    }
}
